#!/usr/bin/env python3
from hamming import compute
import imp
xchar = imp.load_source('xchar', 'xchar')
import sys


def _main():
    if len(sys.argv) < 2:
        print("arg one must be key, or -c to crack")
        exit(1)
    if '-c' in sys.argv:
        out = crack(sys.stdin.buffer.read())[1]
        #sys.stdout.buffer.write(out)
    else:
        out = encode(sys.stdin.buffer.read(), sys.argv[1])
        sys.stdout.buffer.write(out)


def crack(inp):
    # Find the keysize.
    distances = []
    for ks in range(2, min(41, len(inp) // 6 + 1)):
        a = inp[:ks]
        b = inp[ks:2*ks]
        c = inp[2*ks:3*ks]
        d = inp[3*ks:4*ks]

        ab = compute(a, b)
        bc = compute(b, c)
        cd = compute(c, d)

        distances.append((ks, (ab + bc + cd) / (3 * ks)))
    distances.sort(key=lambda t: t[1])

    sizes = [k[0] for k in distances]

    choice_count = min(7, len(sizes))
    keys = []

    # Our list is sorted in order of likely keysizes.
    for i in range(choice_count):
        size = sizes[i]

        blocks = [ [ inp[k + (i * size)] for i in range(len(inp) // size) ] for k in range(size) ]
        key = ''

        for block in blocks:
            key += str(xchar.crack(block)[0])
 
        print("[" + str(size) + "]\t- ", key, file=sys.stderr)
        keys.append(key)

    plain = None if keys[0] is None else encode(inp, keys[0])

    return key, plain


def encode(inp, key):
    out = bytearray()
    for i, byte in enumerate(inp):
        out.append(byte ^ ord(key[i % len(key)]))
    return out


if __main__ == '__main__':
    _main()

